# concurrency_demo
Synchronized学习demo
作用：能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全效果。

两个用法：
1、对象锁：
包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）。
2、类锁：
指synchronized修饰静态的方法或指定锁为Class对象。
概念：
只有一个Class对象：Java类可能有多个java对象，但只有一个Class对象。
本质：所谓的类锁，不过是Class对象锁而已。
用法和效果：类锁只能在同一时刻被一个对象拥有。

性质：
可重入：
概念：指同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁
好处：避免死锁、提升封装性。
粒度：是线程范围而非调用范围。
原理：加锁次数计数器。线程第一次给对象加锁时，设为1,。每当该线程在此对象上再次获得锁时，计数递增。当任务离开时，计数递减，为0时，完全释放锁。
不可中断

缺陷：
效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程。
不够灵活(读写锁更灵活)：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的。
无法知道是否成功获取到锁。

多线程访问同步方法的7种情况：
两个线程同时访问一个对象的同步方法。（同步）
两个线程访问的是两个对象的同步方法。（非同步）
两个线程访问的是synchronized的静态方法。（同步）
同时访问同步方法和非同步方法。（非同步方法不受到影响）
访问同一个对象的不同的普通同步方法。（同步）
同时访问静态synchronized和非静态synchronized方法。（非同步，锁不同）
方法抛异常后，会释放锁。
总结：
一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应1，5的情况）
每个实例都对应有自己的一把锁，不同实例之前互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有的对象共用一把类锁（对应2，3，4，6种情况）
无论是方法正常执行完毕或者方法抛出异常，都会释放锁。（对应第7种情况）

可见性原理：
